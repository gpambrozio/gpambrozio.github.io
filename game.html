<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Responsive Dual Grids with Dynamic Queue</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
    }
    #app {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      box-sizing: border-box;
      min-height: 100vh;
    }
    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 100%;
    }
    .grid-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }
    .grid {
      display: grid;
      gap: 5px;
      grid-template-columns: repeat(5, 1fr);
    }
    .grid-puzzle {
      grid-template-rows: repeat(5, 1fr);
      row-gap: 15px;
    }
    .cell {
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      border: 1px solid #ccc;
      user-select: none;
      aspect-ratio: 1 / 1;
    }
    .cell.clickable {
      cursor: pointer;
    }
    .black {
      background-color: black;
    }
    .empty {
      background-color: #f0f0f0;
    }
    .highlighted {
      border: 3px solid lightgreen;
    }
    .lowercase {
      color: rgb(192, 192, 192);
    }
    .right {
      color: #49c649;
      font-weight: bold;
    }
    .wrong {
      color: #ff0000;
      font-weight: bold;
    }
    .theme-title {
      font-size: 24px;
      margin-bottom: 10px;
      text-align: center;
    }
    .theme-title strong {
      font-size: 28px;
    }
    .theme-selector {
      margin-bottom: 20px;
    }
    .theme-selector select {
      font-size: 22px;
      padding: 5px 10px;
    }
    .rules {
      width: 100%;
      max-width: 600px;
      font-size: 14px;
      line-height: 1.6;
      margin-top: 40px;
    }
    .rules h3 {
      margin-top: 0;
      font-size: 18px;
      text-align: center;
    }
    .grid-label {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 5px;
      text-align: center;
    }
    @media (min-width: 768px) {
      .game-wrapper {
        flex-direction: row;
        justify-content: center;
        align-items: flex-start;
        gap: 40px;
      }
      .game-container {
        flex-direction: row;
        justify-content: center;
        gap: 40px;
      }
      .grid {
        grid-template-columns: repeat(5, 80px);
      }
      .grid-puzzle {
        grid-template-rows: repeat(5, 80px);
      }
      .cell {
        width: 80px;
        height: 80px;
      }
      .rules {
        width: 250px;
        margin-top: 0;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="game-wrapper">
      <div class="game-container">
        <div class="grid-container">
          <div class="theme-selector theme-title">
            <label for="theme-select">Theme: </label>
            <select id="theme-select" v-model="selectedTheme" @change="changeTheme">
              <option v-for="theme in themes" :value="theme.name">{{ theme.name }}</option>
            </select>
          </div>
          <div>
            <div class="grid-label">Puzzle</div>
            <div class="grid grid-puzzle">
              <div 
                v-for="(char, index) in grid1Characters" 
                :key="'grid1-' + index" 
                class="cell clickable" 
                :class="{ 
                  black: char === '-', 
                  empty: char === ' ',
                  highlighted: lastClickedCell === 'grid1-' + index,
                  lowercase: char === char.toLowerCase() && char !== char.toUpperCase(),
                  right: isRight(index) && char !== '-',
                  wrong: isWrong(index) && char !== '-'
                }"
                @click="transferCharacter(index)"
              >
                {{ char !== '-' && char !== ' ' ? char.toUpperCase() : '' }}
              </div>
            </div>
          </div>
          <div>
            <div class="grid-label">Queue</div>
            <div class="grid">
              <div 
                v-for="(char, index) in grid2Characters" 
                :key="'grid2-' + index" 
                class="cell" 
                :class="{ 
                  black: char === '-', 
                  empty: char === ' ',
                  highlighted: index === 0
                }"
              >
                {{ char !== '-' && char !== ' ' ? char : '' }}
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="rules">
        <h3>Game Rules:</h3>
        <ol>
          <li>The top grid represents the main puzzle area.</li>
          <li>The bottom grid contains available letters.</li>
          <li>Click on a cell in the top grid to fill it with the next available letter from the bottom grid.</li>
          <li>You can remove letters from the grid and send it back to the queue but you have to remove them in order.</li>
        </ol>
      </div>
    </div>
  </div>

  <script>
    new Vue({
      el: '#app',
      data: {
        selectedTheme: 'Animals',
        themes: [
          {
            name: 'Animals',
            words: ['Crab', 'Dog', 'hOrsE', 'fIsh', 'liON'],
            letters: ['F', 'R', 'S', 'O', 'A', 'S', 'H', 'G', 'R', 'B', 'L', 'H', 'I']
          },
          {
            name: 'Fruits',
            words: ['ApplE', 'pEar', 'gRaPe', 'mAngo', 'pluM'],
            letters: ['P', 'P', 'A', 'U', 'M', 'E', 'O', 'R', 'G', 'G', 'L', 'P', 'N', 'P', 'L', 'A']
          },
          {
            name: 'Countries',
            words: ['sPaiN', 'ItaLy', 'chiNa', 'indIA', 'peRu'],
            letters: ['C', 'I', 'E', 'S', 'T', 'P', 'A', 'A', 'U', 'A', 'I', 'H', 'I', 'D', 'Y', 'N']
          }
        ],
        words: [],
        grid1Characters: [],
        grid2Characters: [],
        clickOrder: [],
        rowCompleted: [0, 0, 0, 0, 0],
        lastClickedCell: null
      },
      methods: {
        transferCharacter(index) {
          if (this.grid2Characters.length > 0 && this.grid1Characters[index] === ' ') {
            const transferredChar = this.grid2Characters.shift();
            this.clickOrder.push(index);
            this.$set(this.grid1Characters, index, transferredChar);
            this.lastClickedCell = 'grid1-' + index;
            this.checkRowCompletion(index);
          } else if (this.clickOrder.length > 0) {
            const lastClickIndex = this.clickOrder[this.clickOrder.length - 1];
            if (lastClickIndex === index) {
              this.clickOrder.pop();
              const transferredChar = this.grid1Characters[index];
              this.$set(this.grid1Characters, index, ' ');
              this.grid2Characters.unshift(transferredChar);
              if (this.clickOrder.length > 0) {
                const lastClickIndex = this.clickOrder[this.clickOrder.length - 1];
                this.lastClickedCell = 'grid1-' + lastClickIndex;
            } else {
                this.lastClickedCell = null;
              }
            }
            this.checkRowCompletion(index);
          }
        },
        checkRowCompletion(index) {
          const row = Math.floor(index / 5);
          const row_start = row * 5;
          const characters = this.grid1Characters.slice(row_start, row_start + 5);
          if (characters.every(char => char !== ' ')) {
            const word = characters.filter(char => char !== '-').join('');
            if (word.toLowerCase() == this.words[row].toLowerCase()) {
              this.$set(this.rowCompleted, row, 1);
            } else {
              this.$set(this.rowCompleted, row, -1);
            }
          } else {
            this.$set(this.rowCompleted, row, 0);
          }
        },
        isRight(index) {
          const row = Math.floor(index / 5);
          return this.rowCompleted[row] === 1;
        },
        isWrong(index) {
          const row = Math.floor(index / 5);
          return this.rowCompleted[row] === -1;
        },
        changeTheme() {
          const selectedThemeData = this.themes.find(theme => theme.name === this.selectedTheme);
          if (selectedThemeData) {
            this.words = selectedThemeData.words;
            const paddedCharacters = selectedThemeData.words
              .map(word => word.padEnd(5, '-'))
              .flatMap(word => word.split(''))
              .map(char => char === char.toUpperCase() ? char.toLowerCase() : ' ');

            if (selectedThemeData.letters.length == 0) {
              const characters = selectedThemeData.words.join('').split('');
              const lowercaseCharacters = characters.filter(char => char === char.toLowerCase());
              const scrambledCharacters = lowercaseCharacters
                .sort(() => Math.random() - 0.5)
                .map(char => char.toUpperCase());
              this.grid2Characters = scrambledCharacters
              console.log(scrambledCharacters);
            } else {
              this.grid2Characters = [...selectedThemeData.letters];
            }

            this.grid1Characters = paddedCharacters;
            this.lastClickedCell = null;
            this.clickOrder = [];
            this.rowCompleted = [0, 0, 0, 0, 0];
          }
        }
      },
      created() {
        this.changeTheme();
      }
    });
  </script>
</body>
</html>
